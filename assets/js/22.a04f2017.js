(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{227:function(e,t,n){"use strict";n.r(t);var _=n(0),r=Object(_.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),n("Fragment"),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),n("p",[e._v("优点:")]),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6)],1)},[function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"react"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react","aria-hidden":"true"}},[this._v("#")]),this._v(" react")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"虚拟标签"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟标签","aria-hidden":"true"}},[this._v("#")]),this._v(" 虚拟标签")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h3",{attrs:{id:"渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#渲染","aria-hidden":"true"}},[this._v("#")]),this._v(" 渲染")])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ol",[n("li",[n("p",[e._v("当组件的 "),n("code",[e._v("state")]),e._v(" 或 "),n("code",[e._v("props")]),e._v(" 发生改变的时候，"),n("code",[e._v("render")]),e._v(" 函数就会重新执行")])]),e._v(" "),n("li",[n("p",[e._v("当父组件的 "),n("code",[e._v("render")]),e._v(" 函数执行后，对应的所有子组件的 "),n("code",[e._v("render")]),e._v(" 函数都会执行一次")])]),e._v(" "),n("li",[n("p",[e._v("react 生成虚拟DOM，虚拟DOM是js对象，在js里生成js对象进行对比操作，相比于直接对比真实DOM提升了很大的性能")])]),e._v(" "),n("li",[n("p",[e._v("渲染步骤\na. state 数据\nb. JSX 模板\nc. 数据 + 模板 生成虚拟DOM （虚拟DOM就是一个JS对象，用它描述真实的DOM）\nd. 用虚拟DOM的结构生成真实的DOM 来显示\ne. state 发生变化\nf. 数据 + 模板 生成新的虚拟DOM\ng. 比较原始虚拟DOM和新的虚拟DOM的区别，找到不同的地方\nh. 直接操作真实DOM ，改变不同地方的内容")])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ol",[n("li",[n("p",[e._v("性能提升了")])]),e._v(" "),n("li",[n("p",[e._v("他使得跨端应用得以实现。 React Native")])]),e._v(" "),n("li",[n("p",[e._v("生命周期函数\na. "),n("code",[e._v("componentWillMount")]),e._v(" 在组件即将被挂载到页面的时刻自动执行\nb. "),n("code",[e._v("componentDidMount")]),e._v(" 在组件被挂载到页面后，自动执行")])])])},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("p",[e._v("c. "),n("code",[e._v("shouldComponentUpdate")]),e._v(" 在组件被更新之前会自动执行，但需要返回一个布尔类型的结果  true 会执行  false 不会更新\nd. "),n("code",[e._v("componentWillUpdate")]),e._v(" 在组件更新之前，会自动执行，且在 "),n("code",[e._v("shouldComponentUpdate")]),e._v(" 返回 "),n("code",[e._v("true")]),e._v(" 后执行，如果返回 "),n("code",[e._v("false")]),e._v(" 这个函数就不会执行\ne. "),n("code",[e._v("componentDidUpdate")]),e._v(" 在组件更新之后，会自动执行")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("f. "),t("code",[this._v("componentWillReceiveProps")]),this._v(" 当一个组件从父组件接收了参数，只要父组件的 "),t("code",[this._v("render")]),this._v(" 被重新执行后，子组件会执行该生命周期(第一次存在于父组件不会执行，已经在父组件中，才会执行)\ng. "),t("code",[this._v("componentWillUnmount")]),this._v(" 当组件即将被剔除的时候，会被执行（子组件）")])}],!1,null,null,null);t.default=r.exports}}]);