(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{217:function(t,e,i){"use strict";i.r(e);var _=i(0),r=Object(_.a)({},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/skyline75489/what-happens-when-zh_CN",target:"_blank",rel:"noopener noreferrer"}},[t._v("当···时发生了什么？"),i("OutboundLink")],1)]),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),i("p",[t._v("每个宏任务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到该列表中，等宏任务快执 行结束之后，会执行微认为列表，所以微任务依然运行在当前宏任务的执行环境中，这个特性会导致宏任 务和微任务有一些本质上的区别!")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),i("p",[t._v("首先，⻚面中的资源是有优先级的，比如CSS、HTML、JavaScript等都是⻚面中的核心文件，所以优先 级最高;而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需 要“让路”，进入待排队状态。")]),t._v(" "),i("p",[t._v("浏览器会为每个域名最多维护6个TCP连接，如果发起一个HTTP请求时，这6 个TCP连接都处于忙碌状态，那么这个请求就会处于排队状态。")]),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),i("p",[t._v("接下来，就到了Initial connection/SSL阶段了，也就是和服务器建立连接的阶段，这包括了建立TCP连接 所花费的时间;不过如果你使用了HTTPS协议，那么还需要一个额外的SSL握手时间，这个过程主要是用来 协商一些加密信息的。(关于SSL协商的详细过程，我们会在Web安全模块中介绍。)")]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),i("p",[t._v("排队时间过久，大概率是由浏览器为每个域名最多维护6个连接导致的。那么基于这个原因，你就可以让1个 站点下面的资源放在多个域名下面，比如放到3个域名下面，这样就可以同时支持18个连接了，这种方案称 为域名分片技术。除了域名分片技术外，我个人还建议你把站点升级到HTTP2，因为HTTP2已经没有每个 域名最多维护6个TCP连接的限制了。")]),t._v(" "),t._m(19),t._v(" "),i("p",[t._v("这可能的原因有如下:")]),t._v(" "),i("p",[t._v("服务器生成⻚面数据的时间过久。对于动态网⻚来说，服务器收到用戶打开一个⻚面的请求时，首先要从 数据库中读取该⻚面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用戶。服务器在 处理这个数据的过程中，可能某个环节会出问题。")]),t._v(" "),i("p",[t._v("网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用戶要来访问你 的服务器，这样也会拖慢网速。")]),t._v(" "),i("p",[t._v("发送请求头时带上了多余的用戶信息。比如一些不必要的Cookie信息，服务器接收到这些Cookie信息之 后可能需要对每一项都做处理，这样就加大了服务器的处理时⻓。")]),t._v(" "),i("p",[t._v("对于这三种问题，你要有针对性地出一些解决方案。面对第一种服务器的问题，你可以想办法去提高服务器 的处理速度，比如通过增加各种缓存的技术;针对第二种网络问题，你可以使用CDN来缓存一些静态文件; 至于第三种，你在发送请求时就去尽可能地减少一些不必要的Cookie数据信息。")]),t._v(" "),t._m(20),t._v(" "),i("p",[t._v("如果单个请求的Content Download花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。")]),t._v(" "),t._m(21),t._v(" "),i("p",[t._v("在加载阶段，核心的优化原则是: 优化关键资源的加载速度，减少关键资源的个数，降低关键资源的RTT次数。")]),t._v(" "),t._m(22),t._v(" "),i("p",[t._v("在交互阶段，核心的优化原则是: 尽量减少一帧的生成时间。可以通过减少单次JavaScript的执行时间、避 免强制同步布局、避免布局抖动、尽量采用CSS的合成动画、避免频繁的垃圾回收等方式来减少一帧生成的时⻓。")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"浏览器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器","aria-hidden":"true"}},[this._v("#")]),this._v(" 浏览器")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"渲染相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#渲染相关","aria-hidden":"true"}},[this._v("#")]),this._v(" 渲染相关")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"从输入url-到-页面展示，这中间发生了什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从输入url-到-页面展示，这中间发生了什么？","aria-hidden":"true"}},[this._v("#")]),this._v(" 从输入Url 到 页面展示，这中间发生了什么？")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ol",[i("li",[t._v("用戶输入URL，浏览器会根据用戶输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+ 默认搜索引擎合成新的URL;如果用戶输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容 上加上协议合成合法的URL")]),t._v(" "),i("li",[t._v("用戶输入完内容，按下回⻋键，浏览器导航栏显示loading状态，但是⻚面还是呈现前一个⻚面，这是 因为新⻚面的响应数据还没有获得")]),t._v(" "),i("li",[t._v("浏览器进程浏览器构建请求行信息，会通过进程间通信(IPC)将URL请求发送给网络进程\nGET /index.html HTTP1.1")]),t._v(" "),i("li",[t._v("网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回;否则 ，进入网络请求过程")]),t._v(" "),i("li",[t._v("网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会 直接返回缓存信息;否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80 ，https默认443。如果是https请求，还需要建立TLS连接。")]),t._v(" "),i("li",[t._v("Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请 求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个， 会直接建立TCP连接。")]),t._v(" "),i("li",[t._v("TCP三次握手建立连接，http请求加上TCP头部⸺包括源端口号、目的程序端口号和用于校验数据完 整性的序号，向下传输")]),t._v(" "),i("li",[t._v("网络层在数据包上加上IP头部⸺包括源IP地址和目的IP地址，继续向下传输到底层")]),t._v(" "),i("li",[t._v("底层通过物理网络传输给目的服务器主机")]),t._v(" "),i("li",[t._v("目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到 传输层")]),t._v(" "),i("li",[t._v("目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用 层")]),t._v(" "),i("li",[t._v("应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或 者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作 ;如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如 果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了;否则， 返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段: Cache-Control:Max-age=2000 响应数据又顺着应用层⸺传输层⸺网络层⸺网络层⸺传输层⸺应用层的顺序返回到网络进程")]),t._v(" "),i("li",[t._v("数据传输完成，TCP四次挥手断开连接。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就 一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度 Connection:Keep-Alive")]),t._v(" "),i("li",[t._v("网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是 字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行;如果是text/html类型，就通知 浏览器进程获取到文档准备渲染")]),t._v(" "),i("li",[t._v("浏览器进程获取到通知，根据当前⻚面B是否是从⻚面A打开的并且和⻚面A是否是同一个站点(根域 名和协议一样就被认为是同一个站点)，如果满足上述条件，就复用之前网⻚的进程，否则，新创建一个 单独的渲染进程")]),t._v(" "),i("li",[t._v("浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的 “管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程")]),t._v(" "),i("li",[t._v("浏览器收到“确认提交”的消息后，会更新浏览器的⻚面状态，包括了安全状态、地址栏的 URL、前 进后退的历史状态，并更新web⻚面，此时的web⻚面是空白⻚")]),t._v(" "),i("li",[t._v("渲染进程对文档进行⻚面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree(二叉树类似结 构的东西)，CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree(不包 含HTML的具体元素和元素要画的具体位置)，通过Layout可以计算出每个元素具体的宽高颜色位置，结 合起来，开始绘制，最后显示在屏幕中新⻚面显示出来")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"浏览器渲染流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染流程","aria-hidden":"true"}},[this._v("#")]),this._v(" 浏览器渲染流程")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ol",[i("li",[t._v("渲染进程将HTML内容转换为能够读懂的DOM树结构。")]),t._v(" "),i("li",[t._v("渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式。")]),t._v(" "),i("li",[t._v("创建布局树，并计算元素的布局信息。")]),t._v(" "),i("li",[t._v("对布局树进行分层，并生成分层树。")]),t._v(" "),i("li",[t._v("为每个图层生成绘制列表，并将其提交到合成线程。")]),t._v(" "),i("li",[t._v("合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。")]),t._v(" "),i("li",[t._v("合成线程发送绘制图块命令DrawQuad给浏览器进程。")]),t._v(" "),i("li",[t._v("浏览器进程根据DrawQuad消息生成⻚面，并显示到显示器上。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"浏览器进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器进程","aria-hidden":"true"}},[this._v("#")]),this._v(" 浏览器进程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"宏任务与微任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#宏任务与微任务","aria-hidden":"true"}},[this._v("#")]),this._v(" 宏任务与微任务")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"网络进程相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络进程相关","aria-hidden":"true"}},[this._v("#")]),this._v(" 网络进程相关")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"网络面板请求timing相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络面板请求timing相关","aria-hidden":"true"}},[this._v("#")]),this._v(" 网络面板请求Timing相关")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("第一个"),e("code",[this._v("Queuing")]),this._v("，也就是排队的意思，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被 立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("最后，网络进程在为数据分配磁盘空间时，新的HTTP请求也需要短暂地等待磁盘分配结束。 等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的"),e("code",[this._v("Stalled")]),this._v("上，它表示停滞的意思。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这里需要额外说明的是，如果你使用了代理服务器，还会增加一个"),e("code",[this._v("Proxy Negotiation")]),this._v("阶段，也就是代理协 商阶段，它表示代理服务器连接协商所用的时间。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是"),e("code",[this._v("Request sent")]),this._v("阶段。通 常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到 了，所以这个时间通常不到1毫秒。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为"),e("code",[this._v("Waiting (TTFB)")]),this._v("，通常也称 为“"),e("code",[this._v("第一字节时间")]),this._v("”。 TTFB是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明 服务器响应越快。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是"),e("code",[this._v("Content Download")]),this._v("阶段，这意味着从第 一字节时间到接收到全部响应数据所用的时间。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 优化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"浏览器请求时间优化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器请求时间优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 浏览器请求时间优化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("排队(Queuing)时间过久")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"2"}},[e("li",[this._v("第一字节时间(TTFB)时间过久")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"3"}},[e("li",[this._v("Content Download时间过久")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"系统优化页面"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#系统优化页面","aria-hidden":"true"}},[this._v("#")]),this._v(" 系统优化页面")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("什么是RTT？----------\n当使用TCP协议传输一个文件时，比如这个 文件大小是0.1M，由于TCP的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来 回多次进行传输的。RTT就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开 始，到发送端收到来自接收端的确认，总共经历的时延。通常1个HTTP的数据包在14KB左右，所以1个 0.1M的⻚面就需要拆分成8个包来传输了，也就是说需要8个RTT")])])}],!1,null,null,null);e.default=r.exports}}]);